"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8281],{48809:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Value object. This will also determine the types for the object, if they were not strictly given.\\n\\n```lua\\nlocal state = Value.new(false, true)\\n```","params":[{"name":"...","desc":"The initial values you want to store in the new Value object.","lua_type":"b..."}],"returns":[{"desc":"","lua_type":"Value<b...>\\r\\n"}],"function_type":"static","source":{"line":98,"path":"lib/Value.lua"}},{"name":"Set","desc":"Updates the value(s) inside the Value object.\\n\\n```lua\\nstate:Set(true, false)\\n```\\n\\n\\t","params":[{"name":"...","desc":"","lua_type":"b..."}],"returns":[],"function_type":"method","source":{"line":117,"path":"lib/Value.lua"}},{"name":"Get","desc":"Returns all values inside of the Value object.\\n\\n```lua\\nprint(state:Get())\\n```\\n\\n\\t","params":[],"returns":[{"desc":"","lua_type":"b..."}],"function_type":"method","source":{"line":136,"path":"lib/Value.lua"}},{"name":"Clone","desc":"Returns a new Value object with the same values as the original.\\n\\n```lua\\nlocal copiedState = state:Clone()\\n```\\n\\n\\t","params":[],"returns":[{"desc":"","lua_type":"Value<b...>\\r\\n"}],"function_type":"method","source":{"line":151,"path":"lib/Value.lua"}},{"name":"RawSet","desc":"Sets the value of the Value object without firing Changed or WillChange.\\n\\n\\t","params":[{"name":"...","desc":"","lua_type":"b..."}],"returns":[],"function_type":"method","source":{"line":160,"path":"lib/Value.lua"}},{"name":"Destroy","desc":"Destroys the Value object and makes it unusable.\\n\\n```lua\\ncopiedState:Destroy()\\n```\\n\\n\\t","params":[],"returns":[],"function_type":"method","source":{"line":173,"path":"lib/Value.lua"}}],"properties":[{"name":"WillChange","desc":"Is fired before the value changes for [Value].\\n\\n```lua\\nstate.WillChange:Connect(function(foo, bar)\\n\\tprint(foo, bar)\\nend)\\n```","lua_type":"Signal<b...>","tags":["Event"],"source":{"line":71,"path":"lib/Value.lua"}},{"name":"Changed","desc":"Is fired after the value changes for [Value].\\n\\n```lua\\nstate.Changed:Connect(function(foo, bar)\\n\\tprint(foo, bar)\\nend)\\n```","lua_type":"Signal<b...>","tags":["Event"],"source":{"line":84,"path":"lib/Value.lua"}}],"types":[],"name":"Value","desc":"An object used to store states, and trigger every [Connection] listening to its [Signal] members.\\n\\n```lua\\nlocal state = Value.new(false, true)\\n\\nstate.WillChange:Connect(function(foo, bar)\\n\\tprint(foo, bar)\\nend)\\n\\nstate.Changed:Connect(function(foo, bar)\\n\\tprint(foo, bar)\\nend)\\n\\nstate:Set(true, false)\\n\\ntask.wait(1)\\n\\nlocal copiedState = state:Clone()\\n\\nprint(\\"These are the current states:\\", copiedState:Get())\\n\\ncopiedState:Destroy()\\n```\\n\\n:::caution String Literals\\nIt should be noted that for one reason or another, Value is not able to typecheck string literals properly.","source":{"line":57,"path":"lib/Value.lua"}}')}}]);