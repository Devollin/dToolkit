"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7690],{70950:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new SimpleValue object. This will also determine the types for the object, if they were not strictly given.\\n\\n```lua\\nlocal state = SimpleValue.new(false)\\n```","params":[{"name":"init","desc":"The initial value you want to store in the new SimpleValue object.","lua_type":"a"}],"returns":[{"desc":"","lua_type":"SimpleValue<a>\\r\\n"}],"function_type":"static","source":{"line":111,"path":"lib/SimpleValue.lua"}},{"name":"Set","desc":"Updates the value inside the SimpleValue object.\\n\\n```lua\\nstate:Set(true)\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"SimpleValue<a>"},{"name":"newValue","desc":"","lua_type":"a"}],"returns":[],"function_type":"static","source":{"line":128,"path":"lib/SimpleValue.lua"}},{"name":"Get","desc":"Returns the value of the SimpleValue object.\\n\\n```lua\\nprint(state:Get())\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"SimpleValue<a>"}],"returns":[{"desc":"","lua_type":"a\\r\\n"}],"function_type":"static","source":{"line":147,"path":"lib/SimpleValue.lua"}},{"name":"Clone","desc":"Returns a new SimpleValue object with the same value as the original.\\n\\n```lua\\nlocal copiedState = state:Clone()\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"SimpleValue<a>"}],"returns":[{"desc":"","lua_type":"SimpleValue<a>\\r\\n"}],"function_type":"static","source":{"line":160,"path":"lib/SimpleValue.lua"}},{"name":"RawSet","desc":"Sets the value of the SimpleValue object without firing Changed.\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"SimpleValue<a>"},{"name":"newValue","desc":"","lua_type":"a"}],"returns":[],"function_type":"static","source":{"line":169,"path":"lib/SimpleValue.lua"}},{"name":"Destroy","desc":"Destroys the SimpleValue object and makes it unusable.\\n\\n```lua\\ncopiedState:Destroy()\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"SimpleValue<a>"}],"returns":[],"function_type":"static","source":{"line":182,"path":"lib/SimpleValue.lua"}}],"properties":[{"name":"OnlyUpdateIfDifferent","desc":"Enabling this makes it so future attempts to use :Set() or :RawSet() are first compared to the current value; if they\\nare determined to be the same value, then it will not fire the .Changed [Signal].\\n\\n```lua\\nstate.OnlyUpdateIfDifferent = true\\n```","lua_type":"boolean","tags":["Event"],"source":{"line":83,"path":"lib/SimpleValue.lua"}},{"name":"Changed","desc":"Is fired after the value changes for [SimpleValue]. The first passed item is the new value, the second is the old value.\\n\\n```lua\\nstate.Changed:Connect(function(newValue, oldValue)\\n\\tprint(newValue, oldValue)\\nend)\\n```","lua_type":"Signal<a, a>","tags":["Event"],"source":{"line":97,"path":"lib/SimpleValue.lua"}}],"types":[],"name":"SimpleValue","desc":"An object used to store a single state, and trigger every [Connection] listening to its [Signal] members.\\n\\n```lua\\nlocal state = SimpleValue.new(false)\\n\\nstate.Changed:Connect(function(newValue, oldValue)\\n\\tprint(newValue, oldValue)\\nend)\\n\\nstate:Set(true)\\n\\ntask.wait(1)\\n\\nlocal copiedState = state:Clone()\\n\\nprint(\\"This is the current state:\\", copiedState:Get())\\n\\ncopiedState:Destroy()\\n```\\n\\n:::caution String Literals\\nIt should be noted that for one reason or another, SimpleValue is not able to typecheck string literals properly.\\n\\n:::info\\nThere is an alternative type named InternalSimpleValue, which can be used for classes built using it! The primary\\ndifference is that InternalSimpleValue drops the :Set(), :Destroy(), and :RawSet() methods, but only from the type, not\\nthe object.","source":{"line":70,"path":"lib/SimpleValue.lua"}}')}}]);