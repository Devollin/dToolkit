"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7700],{49164:n=>{n.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Signal object.\\n\\n```lua\\nlocal newSignal: Signal<boolean, string> = Signal.new()\\n```","params":[],"returns":[{"desc":"","lua_type":"Signal<a...>\\r\\n"}],"function_type":"static","source":{"line":175,"path":"lib/Signal.lua"}},{"name":"Connect","desc":"Adds a listener for the [Signal], and returns a [Connection].\\n\\n```lua\\nlocal newConnection = newSignal:Connect(function(foo, bar)\\n\\tif foo then\\n\\t\\tprint(bar)\\n\\telse\\n\\t\\tprint(bar:reverse())\\n\\tend\\nend)\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"},{"name":"callback","desc":"","lua_type":"(a...) -> ()"}],"returns":[{"desc":"","lua_type":"Connection<a...>\\r\\n"}],"function_type":"static","source":{"line":194,"path":"lib/Signal.lua"}},{"name":"Destroy","desc":"Disconnects every [Connection] to the [Signal].\\n\\n```lua\\nnewSignal:Destroy()\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"}],"returns":[],"function_type":"static","source":{"line":215,"path":"lib/Signal.lua"}},{"name":"Clear","desc":"Disconnects every [Connection] to the [Signal].\\n\\n```lua\\nnewSignal:Destroy()\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"}],"returns":[],"function_type":"static","source":{"line":230,"path":"lib/Signal.lua"}},{"name":"Fire","desc":"Triggers every [Connection] that is subscribed to the [Signal], passing along any parameters in the process.\\n\\n```lua\\nnewSignal:Fire(true, \\"boot\\")\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"},{"name":"...","desc":"","lua_type":"a..."}],"returns":[],"function_type":"static","source":{"line":243,"path":"lib/Signal.lua"}},{"name":"Wait","desc":"Waits until the [Signal] is fired, and returns any parameters passed with it.\\n\\n```lua\\ntask.spawn(function()\\n\\ttask.wait(5)\\n\\t\\n\\tnewSignal:Fire(false, \\"bar\\")\\nend)\\n\\nlocal foo, bar = newSignal:Wait()\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"}],"returns":[{"desc":"","lua_type":"a..."}],"function_type":"static","yields":true,"source":{"line":279,"path":"lib/Signal.lua"}},{"name":"Once","desc":"Returns a [Connection], which will be automatically disconnected when the [Signal] is fired.\\n\\n```lua\\nlocal tempConnection = newSignal:Once(function(foo, bar)\\n\\tprint(\\"i am self-destructing now!\\", foo, bar)\\nend)\\n\\nnewSignal:Fire(true, \\"boo!\\")\\nnewSignal:Fire(false, \\"scared them too much, oops\\")\\n```\\n\\n\\t","params":[{"name":"self","desc":"","lua_type":"Signal<a...>"},{"name":"callback","desc":"","lua_type":"(a...) -> ()"}],"returns":[{"desc":"","lua_type":"Connection<a...>\\r\\n"}],"function_type":"static","source":{"line":306,"path":"lib/Signal.lua"}}],"properties":[],"types":[],"name":"Signal","desc":"A Signal class used to create custom events.\\n\\n```lua\\nlocal newSignal: Signal<boolean, string> = Signal.new()\\n\\nlocal newConnection = newSignal:Connect(function(foo, bar)\\n\\tif foo then\\n\\t\\tprint(bar)\\n\\telse\\n\\t\\tprint(bar:reverse())\\n\\tend\\nend)\\n\\nnewSignal:Fire(true, \\"boot\\")\\n\\nnewConnection:Disconnect()\\n```\\n\\n:::info\\nThere is an alternative type named InternalSignal, which can be used for classes built using it! The primary difference is\\nthat InternalSignal drops the :Fire(), :Destroy(), and :Clear() methods, but only removes them from the type, not from the\\nobject.","source":{"line":163,"path":"lib/Signal.lua"}}')}}]);